#!/usr/bin/env python3
"""Autogenerate the native golden fixture header from the manifest."""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Dict, Iterable, List

HEADER_BANNER = """// @generated by scripts/generate_native_golden_header.py. Edit with caution."""


def load_manifest(path: Path) -> Dict[str, object]:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def collect_fixtures(fixtures: Iterable[Dict[str, object]], kind: str) -> List[Dict[str, object]]:
    items: List[Dict[str, object]] = []
    for entry in fixtures:
        if not isinstance(entry, dict):
            continue
        if entry.get("kind") != kind:
            continue
        if not entry.get("name") or not entry.get("path") or not entry.get("hash"):
            continue
        items.append(entry)
    items.sort(key=lambda item: item.get("name", ""))
    return items


def render_array(name: str, fixtures: List[Dict[str, object]]) -> str:
    lines = [f"constexpr FixtureInfo {name}[] = {{"]
    for fixture in fixtures:
        lines.append(
            "    {" + 
            f"\"{fixture['name']}\", "
            f"\"{fixture['path']}\", "
            f"\"{fixture['hash']}\"" +
            "},"
        )
    lines.append("};")
    lines.append(f"constexpr std::size_t {name[:-1]}Count = sizeof({name}) / sizeof({name}[0]);")
    return "\n".join(lines)


def render_header(audio: List[Dict[str, object]], logs: List[Dict[str, object]]) -> str:
    parts = [
        "#pragma once",
        HEADER_BANNER,
        "",
        "#include <cstddef>",
        "",
        "namespace native_golden {",
        "",
        "struct FixtureInfo {",
        "    const char* name;",
        "    const char* path;",
        "    const char* expected_hash;",
        "};",
        "",
        render_array("kAudioFixtures", audio),
        "",
        render_array("kLogFixtures", logs),
        "",
        "}  // namespace native_golden",
        "",
    ]
    return "\n".join(parts)


def main() -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--manifest", type=Path, default=Path("tests/native_golden/golden.json"))
    parser.add_argument("--header", type=Path, default=Path("tests/native_golden/fixtures_autogen.hpp"))
    parser.add_argument("--check", action="store_true", help="Fail if the header would change")
    args = parser.parse_args()

    manifest = load_manifest(args.manifest)
    fixtures = manifest.get("fixtures", [])
    audio = collect_fixtures(fixtures, "audio")
    logs = collect_fixtures(fixtures, "log")

    header_body = render_header(audio, logs)

    if args.header.exists():
        current = args.header.read_text(encoding="utf-8")
        if current == header_body:
            return 0
        if args.check:
            print("header out of date", flush=True)
            return 1
    if args.check:
        return 0

    args.header.parent.mkdir(parents=True, exist_ok=True)
    args.header.write_text(header_body, encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
